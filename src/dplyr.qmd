---
knitr:
  opts_chunk: 
    comment: ''
---
# Introduction to dplyr {#sec-dplyr}

The [**dplyr**](https://dplyr.tidyverse.org/) package offers extensive functionality for 
data manipulation.
<br><br>
dplyr's functions are named after verbs (like `filter`, `select`, etc.) and are commonly
used with the pipe operator to build pipelines. The package offers a large number of 
functions in total, often with multiple versions of the same "verb". It has 
undergone many major changes since its introduction, so always make sure to 
consult the latest documentation.

Core operations include:

- `filter()`: identify cases
- `select()`: identify columns
- `mutate()`: create new variables as a function of existing ones
- `arrange()`: reorder the rows/cases of a dataset
- `summarize()`: apply functions on columns 
- `group_by()`: identify columns to group rows/cases by. All of the above can be applied on a grouped data frame

**dplyr** operates on data.frames as well as the tidyverse's data.frame 
replacement, known as [**tibble**](https://tibble.tidyverse.org/).

Note that **dplyr** masks some builtin functions when loaded.

```{r}
library(readr)
library(dplyr)
```

As an example, we read in the 
[Heart Failure Clinical Records](https://archive.ics.uci.edu/ml/datasets/Heart+failure+clinical+records) 
dataset from the 
[UCI Machine Learning Repository](https://archive.ics.uci.edu/ml/index.php) using
[readr](#sec-readrdataio).

For this example, we are showing how you can specify column types when reading in data using the `col_types` argument of `readr`'s `read_csv()` function. In practice, you may want to let `readr` infer column types automatically and fix any types, as needed, afterwards.

```{r}
dat <- read_csv(
    "https://archive.ics.uci.edu/ml/machine-learning-databases/00519/heart_failure_clinical_records_dataset.csv",
    col_types = cols(
        age = col_double(),
        anaemia = col_factor(),
        creatinine_phosphokinase = col_double(),
        diabetes = col_factor(),
        ejection_fraction = col_double(),
        high_blood_pressure = col_factor(),
        platelets = col_double(),
        serum_creatinine = col_double(),
        serum_sodium = col_double(),
        sex = col_factor(),
        smoking = col_factor(),
        time = col_double(),
        DEATH_EVENT = col_factor()
    )
)
```

::: callout-note
`dplyr` and the tidyverse in general operate on data.frames and 
[tibbles](https://tibble.tidyverse.org/), which can be used as a drop-in replacement
for data.frames, and heavily promote the use of the [pipe](#sec-pip) 
operator `|>`.
:::

## Filter

Single condition

```{r}
dat |> 
    filter(age > 60)
```

Multiple conditions

```{r}
dat |> 
    filter(age > 60, anaemia == "1")
```

## Select

Columns can be specified by name, index, or pattern-matching.

### By column name

```{r}
dat |> 
    select("age", "diabetes", "ejection_fraction")
```

### By integer column index

```{r}
dat |> 
    select(c(7, 9))
```

```{r}
dat |> 
    select(7:9)
```

### By character name range

For example, select all columns between `platelets` and `serum_sodium` in the order
they appear in the data.frame/tibble:

```{r}
dat |> 
    select(platelets:serum_sodium)
```

### Pattern-matching

```{r}
dat |> 
    select(starts_with("serum_"))
```

```{r}
dat |> 
    select(ends_with("fraction"))
```

## Count

Count the number of smokers over age 60 by sex:

```{r}
dat |> 
    filter(smoking == "1", age > 60) |> 
    count(sex)
```

## Summarize

Operate on a single column:

```{r}
dat |> 
    summarize(mean(age))
```

Operate on multiple columns using `across()`:

```{r}
dat |> 
    summarize(across(c(age, ejection_fraction), mean))
```

### Grouped operation on single column

with single grouping variable:

```{r}
dat |> 
    group_by(sex) |> 
    summarize(mean(age))
```

or using the `.by` argument of `summarize()`:

```{r}
dat |> 
    summarize(mean(age), .by = sex)
```

with multiple grouping variables:

```{r}
dat |> 
    group_by(sex, diabetes) |>
    summarize(mean(age))
```

or

```{r}
dat |> 
    summarize(mean(age), .by = c(sex, diabetes))
```

### Grouped operation on multiple columns

Group by single variable:

```{r}
dat |> 
    group_by(sex) |> 
    summarize(across(c(age, serum_sodium), mean))
```

or:

```{r}
dat |> 
    summarize(across(c(age, serum_sodium), mean), .by = sex)
```

Group by multiple variables:

```{r}
dat |> 
    group_by(smoking, anaemia) |> 
    summarize(across(c(age, serum_sodium), mean))
```

or:

```{r}
dat |> 
    summarize(across(c(age, serum_sodium), mean), .by = c(smoking, anaemia))
```

## Arrange

`arrange()` sorts a data.frame/tibble, i.e. reorders the rows/cases of a dataset.

```{r}
dat |> 
    select(age, sex, serum_sodium) |> 
    arrange(age)
```

## Slice

Return the row with the highest ejection_fraction value:

```{r}
dat |>
  slice_max(ejection_fraction)
```

Return the row with the minimum age:

```{r}
dat |>
  slice_min(age)
```

::: callout-note
`slice_max()` and `slice_min()` return all rows with the maximum/minimum value by
default. To return only a single row, use the `with_ties = FALSE` argument.
:::

```{r}
dat |>
  slice_min(age, with_ties = FALSE)
```

## Relocate

Move the `sex` column after the `age` column:

```{r}
dat <- dat |>
    relocate(sex, .after = age)

names(dat)
```

Make the `diabetes` column the last column:

```{r}
dat <- dat |>
    relocate(diabetes, .after = last_col())

names(dat)
```

Note: above we use `names()` to show the column names of the resulting data.frame/tibble and verify the changes, since only the first few columns are printed by default.

## Mutate

Add a new column named `Age_days`:

```{r}
dat <- dat |> 
    mutate(Age_days = age * 365)
```

```{r}
dat["Age_days"]
```

## Rename

Rename the `DEATH_EVENT` to `Mortality`:

```{r}
dat <- dat |> 
    rename(Mortality = DEATH_EVENT)

names(dat)
```

### Mutate by group

```{r}
dat <- dat |> 
    group_by(sex) |> 
    mutate(demeaned_sodium_bysex = serum_sodium - mean(serum_sodium)) |> 
    ungroup()
```

::: callout-important
Note that `ungroup()` is required to return the data.frame/tibble to its original
ungrouped state. If you don't do this, all subsequent operations will be performed on
the same grouping.
:::

Inspect the new column:

```{r}
dat |> 
    select(sex, serum_sodium, demeaned_sodium_bysex)
```

## Specifying multiple columns

dplyr includes a number of ways to identify multiple variables.
The latest version of dplyr suggests using `across()` within dplyr functions 
that allow specifying columns, as we've used above.
<br><br>
This replaces separate functions previously used for each of 
`filter/select/mutate/summarize/arrange` that had independent functions ending 
with  `*_all()`, `*_at()`, `*_each()`, `*_if()`.
<br><br>
Other than specifying multiple columns by name, they can also be specified by
index, by range, or by pattern-matching.

### By integer column index

```{r}
dat |> 
    summarize(across(c(7, 9), mean))
```

```{r}
dat |> 
    summarize(across(7:9, mean))
```

### By character name range

For example, select all columns between `platelets` and `serum_sodium` in the order
they appear in the data.frame/tibble:

```{r}
dat |> 
    summarize(across(platelets:serum_sodium, mean))
```

### Pattern-matching

```{r}
dat |> 
    summarize(across(starts_with("serum_"), mean))
```

```{r}
dat |> 
    summarize(across(ends_with("fraction"), mean))
```

### Using predicate function wrapped in `where()`

::: callout-tip
A predicate function is a function that returns a logical value, i.e. either `TRUE` or 
`FALSE`.
:::

For example, you can use `is.*` functions to identify columns based on their type, 
e.g. numeric or factor.

```{r}
dat |> 
    summarize(across(where(is.numeric), mean))
```

To use a summary function that returns more than one row per group, use `reframe()`
instead of `summarize()`. For example, to get the range (min and max) of all numeric columns:

```{r}
dat |> 
    reframe(across(where(is.numeric), range))
```

### Using anonymous predicate function with `where()`

It is often useful to be able to get the number of unique values per column, e.g. in 
order to identify which columns may need to be converted to factors.
`dplyr` includes the function `n_distinct()` which counts the number of unique values of
a vector.
<br><br>
The following example shows dplyr's 
[formula shorthand](https://tidyselect.r-lib.org/reference/where.html#the-formula-shorthand) 
syntax to build an anonymous function using `n_distinct()` in order to select columns with 
fewer than 10 unique values:

```{r}
dat |> 
    select(where(~ n_distinct(.x) < 10))
```

which is equivalent to using a standard R anonymous function:

```{r}
dat |> 
    select(where(\(x) n_distinct(x) < 10))
```

`n_distinct(x)` is equivalent to `length(unique(x))`:

```{r}
dat |> 
    select(where(\(x) length(unique(x)) < 10))
```

To mutate those columns to factors, we combine `across()` and `where()` with the
formula notation seen above within `mutate()`:

```{r}
dat <- dat |> 
    mutate(across(where(~ n_distinct(.) < 10), as.factor))
```

```{r}
str(dat)
```

## Combining multiple dplyr operations

For example, filter for smokers over age 60 and show mean platelets by sex:

```{r}
dat |> 
    filter(smoking == "1", age > 60) |> 
    group_by(sex) |> 
    summarize(mean(platelets))
```

## dplyr backends

Using dplyr on data.frames or tibbles does not offer any performance benefits over 
performing the equivalent operations in base R (and may in fact be slightly slower).

A number of alternative [backends](https://dplyr.tidyverse.org/#backends), at different 
stages of maturity, are available that offer performance benefits for large datasets.

## Resources {#dplyrresources}

- [dplyr website](https://dplyr.tidyverse.org/)
- [dplyr cheatsheet](https://github.com/rstudio/cheatsheets/blob/master/data-transformation.pdf)
- [tibble website](https://tibble.tidyverse.org/)

## See also

- [data.table](#sec-datatable)
